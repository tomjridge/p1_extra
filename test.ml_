(* -*- mode: tuareg -*- *)

(* interactive top-level testing having installed ml files *)

#require "p1_core";;
#require "p1_extra";;



(* examples --------------------------------------------------------- *)

open Tjr_substring
open P1_combinators 

(* for testing FIXME use Tjr_substring.a *)
let a1 (s:substring_) = (
  if s.i_ < s.j_ && s.s_.[s.i_] = '1' then
    [("1",{s with i_ = s.i_ + 1})]
  else
    [])

open P1_core

let a1 : string parser_ = (fun i -> a1 i.ss)

let _ = "11111" |> run_parser (iter ~n:5 a1)
let _ = "1111" |> run_parser (iter ~n:5 a1)
let _ = "111111" |> run_parser (iter ~n:5 a1)

;;
let _ = "1111" |> run_parser (star ~sep:eps a1)


(* parse_grammar_file ----------------------------------------------- *)

open Parse_grammar_file

let _ = grammar_to_parser

let example = {|

S -> e=E ?ws? ?eof? {{ print_endline (x1 |> string_of_int) }}

E -> x=E y=E z=E {{ x+y+z }}
| "1"  {{ 1 }}
| ""   {{ 0 }}

|}

(* FIXME move elsewhere *)
let rec pp_rule = function
  | `Rule(`Nt nt,`Rhs[`List sas]) -> (nt,List.map pp_sas sas)
  | _ -> err __LOC__
and pp_sas = function
  | `Symsact (syms,code) -> (List.map pp_sym syms,code)
  | _ -> err __LOC__
and pp_sym' = function
    | `Nt s -> `Nt s
    | `Dq s -> `Dq s
    | `Qu s -> `Qu s
    | `Sq s -> `Sq s
    | _ -> err __LOC__
and pp_sym = function
  | `Var_eq (None,x) -> (`Elt(None,x |> pp_sym'))
  | `Var_eq (Some v,x) -> (`Elt(Some v,x |> pp_sym'))
  | _ -> err __LOC__
and pp_rules = function
  | `List rs -> List.map pp_rule rs
  | _ -> (err __LOC__)

let x = 
  example |> run_parser (grammar_to_parser "Grammar") 
  |> function [x] -> x 

let x' = x|> pp_rules

type sym = [ `Nt of string | `Qu of string | `Sq of string | `Dq of string ]

type elt = [ `Elt of (string option * sym) ]

type rule = {nt:string; rhs: (elt list * string) list }

let rs : rule list = 
  x' 
  |> List.map (fun (nt,rhs) -> {nt;rhs})


(* code gen --------------------------------------------------------- *)


let pp_sym = String.(function
  | `Nt s -> "_"^s  (* prefix with an underscore since we need nts to be func names *)
  | `Qu s -> s
  | `Sq s -> "a "^dq^(escaped s)^dq  (* FIXME protect *)
  | `Dq s -> "a "^dq^(escaped s)^dq
  )

let pp_elt = function `Elt (_,sym) -> pp_sym sym

let _fun n = 
  begin
    match n with
    | 1 -> ["x1"]
    | 2 -> ["x1";"x2"]
    | 3 -> ["x1";"x2";"x3"]
    | 4 -> ["x1";"x2";"x3";"x4"]
    | _ -> failwith __LOC__
  end
  |> fun vs ->
  let rec pp = function 
    | [v] -> v
    | [v1;v2] -> "("^v1^","^v2^")"
    | v::vs -> "("^v^","^pp vs^")"
  in
  "fun "^pp vs^" -> "

let pp_rule r = (
  pp_sym (`Nt r.nt) ^ " = " ^ begin
    r.rhs 
    |> List.map (fun (es,code) -> 
        es |> List.map pp_elt |> Tjr_string.concat_strings ~sep:" **> " |> fun es' ->
        "("^es'^" >> ("^_fun (List.length es)^code^") )")
    |> Tjr_string.concat_strings ~sep:"|||\n    "
  end)

let pp_rules rs = 
  rs |> List.map pp_rule |> Tjr_string.concat_strings ~sep:" and \n\n" |> fun body ->
  "let rec \n"^ body

let _ = pp_rules rs |> print_endline
